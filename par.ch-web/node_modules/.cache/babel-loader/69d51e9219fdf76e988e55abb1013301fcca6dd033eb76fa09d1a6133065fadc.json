{"ast":null,"code":"// import * as THREE from 'three';\n\n// // const scene = new THREE.Scene();\n// // const camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );\n// const ViewerBG = '#eee';\n// const ViewerUI = {\n// \tcanvasWrapper: document.getElementById('viewerCanvasWrapper'),\n// \tcubeWrapper: document.getElementById('orientCubeWrapper'),\n// \ttoggleZoom: document.getElementById('toggleZoom'),\n// \ttogglePan: document.getElementById('togglePan'),\n// \ttoggleOrbit: document.getElementById('toggleOrbit'),\n// \tresetBtn: document.getElementById('resetBtn'),\n// \ttoggleModelBrowser: document.getElementById('toggleModelBrowser'),\n// \tmodelBrowser: document.getElementById('modelBrowser'),\n// \tmodelBrowserContent: document.getElementById('modelBrowserContent'),\n// \tfileInput: document.getElementById('fileInput'),\n// \texplodeSliderWrapper: document.getElementById('explodeSliderWrapper'),\n// \texplodeSlider: document.getElementById('explodeSlider'),\n// \ttoggleExplode: document.getElementById('toggleExplode'),\n// \ttoggleShare: document.getElementById('toggleShare'),\n// \tshareSidebar: document.getElementById('shareSidebar'),\n// \tloader: document.getElementById('loader'),\n// \ttoggleMeasure: document.getElementById('toggleMeasure'),\n// \tloaderInfo: document.getElementById('loaderInfo'),\n// \tbackToHome: document.getElementById('backToHome'),\n// \twebglContainer: document.getElementById('webglContainer'),\n// \tdownloadScreen: document.getElementById('downloadScreen'),\n// \texplodeFace: document.getElementById('explodeFace')\n// };\n\n// function setItemSelected(ele, bool) {\n// \tif (bool) {\n// \t\tele.classList.add('item-selected');\n// \t} else {\n// \t\tele.classList.remove('item-selected');\n// \t}\n// }\n\n// function toggle(ele) {\n// \tif (ele.getBoundingClientRect().height > 0) {\n// \t\tele.style.display = 'none';\n// \t\treturn false;\n// \t} else {\n// \t\tele.style.display = 'block';\n// \t\treturn true;\n// \t}\n// }\n\n// function toggleThrough(ele, through, cb, selected=true) {\n// \t// through.onclick = () => {\n// \t// \tlet bool = toggle(ele);\n// \t// \tselected && setItemSelected(through, bool);\n// \t// \tcb && cb(bool);\n// \t// }\n// }\n\n// function show(ele) {\n// \tele.style.display = 'block';\n// }\n\n// function hide(ele) {\n// \tele.style.display = 'none';\n// }\n\n// export default function ModelViewer() {\n\n// \t// ViewerUI.downloadScreen.onclick = function() {\n// \t// \tconst canvas = renderer.domElement;\n// \t// \trenderAll();\n// \t// \tconst image = canvas.toDataURL(\"image/png\");\n// \t// \tconst a = document.createElement(\"a\");\n// \t// \ta.href = image.replace(/^data:image\\/[^;]/, 'data:application/octet-stream');\n// \t// \ta.download = \"image.png\"\n// \t// \ta.click();\n// \t// }\n\n// \t// ViewerUI.explodeFace.onclick = function() {\n// \t// \texplodeFace = this.checked;\n// \t// \tresetExplode();\n// \t// \texplode();\n// \t// }\n\n// \tlet cubeCameraDistance = 1.75;\n\n// \tlet cubeWrapper = ViewerUI.cubeWrapper;\n// \tlet cubeScene = new THREE.Scene();\n// \tlet cubeCamera = new THREE.PerspectiveCamera(70, cubeWrapper.offsetWidth / cubeWrapper.offsetHeight, 0.1, 100);\n// \tlet cubeRenderer = new THREE.WebGLRenderer({\n// \t\talpha: true,\n// \t\tantialias: true,\n// \t\tpreserveDrawingBuffer: true\n// \t}); \n\n// \tcubeRenderer.setSize(cubeWrapper.offsetWidth, cubeWrapper.offsetHeight);\n// \tcubeRenderer.setPixelRatio(window.deivicePixelRatio);\n\n// \tcubeWrapper.appendChild(cubeRenderer.domElement);\n\n// \tlet materials = [];\n// \tlet texts = ['RIGHT', 'LEFT', 'TOP', 'BOTTOM', 'FRONT', 'BACK'];\n\n// \tlet textureLoader = new THREE.TextureLoader();\n// \tlet canvas = document.createElement('canvas');\n// \tlet ctx = canvas.getContext('2d');\n\n// \tlet size = 64;\n// \tcanvas.width = size;\n// \tcanvas.height = size;\n\n// \tctx.font = 'bolder 12px \"Open sans\", Arial';\n// \tctx.textBaseline = 'middle';\n// \tctx.textAlign = 'center';\n\n// \tlet mainColor = '#fff';\n// \tlet otherColor = '#ccc';\n\n// \tlet bg = ctx.createLinearGradient(0, 0, 0, size);\n// \tbg.addColorStop(0, mainColor);\n// \tbg.addColorStop(1,  otherColor);\n\n// \tfor (let i = 0; i < 6; i++) {\n// \t\tif (texts[i] == 'TOP') {\n// \t\t\tctx.fillStyle = mainColor;\n// \t\t} else if (texts[i] == 'BOTTOM') {\n// \t\t\tctx.fillStyle = otherColor;\n// \t\t} else {\n// \t\t\tctx.fillStyle = bg;\n// \t\t}\n// \t\tctx.fillRect(0, 0, size, size);\n// \t\tctx.strokeStyle = '#aaa';\n// \t\tctx.setLineDash([8, 8]);\n// \t\tctx.lineWidth = 4;\n// \t\tctx.strokeRect(0, 0, size, size);\n// \t\tctx.fillStyle = '#999';\n// \t\tctx.fillText(texts[i], size / 2, size / 2);\n// \t\tmaterials[i] = new THREE.MeshBasicMaterial({\n// \t\t\tmap: textureLoader.load(canvas.toDataURL())\n// \t\t});\n// \t}\n\n// \tlet planes = [];\n\n// \tlet planeMaterial = new THREE.MeshBasicMaterial({\n// \t\tside: THREE.DoubleSide,\n// \t\tcolor: 0x00c0ff,\n// \t\ttransparent: true,\n// \t\topacity: 0,\n// \t\tdepthTest: false\n// \t});\n// \tlet planeSize = 0.7;\n// \tlet planeGeometry = new THREE.PlaneGeometry(planeSize, planeSize);\n\n// \tlet a = 0.51;\n\n// \tlet plane1 = new THREE.Mesh(planeGeometry, planeMaterial.clone());\n// \tplane1.position.z = a;\n// \tcubeScene.add(plane1);\n// \tplanes.push(plane1);\n\n// \tlet plane2 = new THREE.Mesh(planeGeometry, planeMaterial.clone());\n// \tplane2.position.z = -a;\n// \tcubeScene.add(plane2);\n// \tplanes.push(plane2);\n\n// \tlet plane3 = new THREE.Mesh(planeGeometry, planeMaterial.clone());\n// \tplane3.rotation.y = Math.PI / 2;\n// \tplane3.position.x = a;\n// \tcubeScene.add(plane3);\n// \tplanes.push(plane3);\n\n// \tlet plane4 = new THREE.Mesh(planeGeometry, planeMaterial.clone());\n// \tplane4.rotation.y = Math.PI / 2;\n// \tplane4.position.x = -a;\n// \tcubeScene.add(plane4);\n// \tplanes.push(plane4);\n\n// \tlet plane5 = new THREE.Mesh(planeGeometry, planeMaterial.clone());\n// \tplane5.rotation.x = Math.PI / 2;\n// \tplane5.position.y = a;\n// \tcubeScene.add(plane5);\n// \tplanes.push(plane5);\n\n// \tlet plane6 = new THREE.Mesh(planeGeometry, planeMaterial.clone());\n// \tplane6.rotation.x = Math.PI / 2;\n// \tplane6.position.y = -a;\n// \tcubeScene.add(plane6);\n// \tplanes.push(plane6);\n\n// \tlet groundMaterial = new THREE.MeshBasicMaterial({\n// \t\tcolor: 0xaaaaaa\n// \t});\n// \tlet groundGeometry = new THREE.PlaneGeometry(1, 1);\n// \tlet groundPlane = new THREE.Mesh(groundGeometry, groundMaterial);\n// \tgroundPlane.rotation.x = -Math.PI / 2;\n// \tgroundPlane.position.y = -0.6;\n\n// \tcubeScene.add(groundPlane);\n\n// \tlet cube = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 1), materials);\n// \tcubeScene.add(cube);\n\n// \tfunction updateCubeCamera() {\n// \t\tcubeCamera.rotation.copy(camera.rotation);\n// \t\tlet dir = camera.position.clone().sub(controller.target).normalize();\n// \t\tcubeCamera.position.copy(dir.multiplyScalar(cubeCameraDistance));\n// \t}\n\n// \tlet activePlane = null;\n\n// \tcubeRenderer.domElement.onmousemove = function(evt) {\n\n// \t\tif (activePlane) {\n// \t\t\tactivePlane.material.opacity = 0;\n// \t\t\tactivePlane.material.needsUpdate = true;\n// \t\t\tactivePlane = null;\n// \t\t}\n\n// \t\tlet x = evt.offsetX;\n// \t\tlet y = evt.offsetY;\n// \t\tlet size = cubeRenderer.getSize(new THREE.Vector2());\n// \t\tlet mouse = new THREE.Vector2(x / size.width * 2 - 1, -y / size.height * 2 + 1);\n\n// \t\tlet raycaster = new THREE.Raycaster();\n// \t\traycaster.setFromCamera(mouse, cubeCamera);\n// \t\tlet intersects = raycaster.intersectObjects(planes.concat(cube));\n\n// \t\tif (intersects.length > 0 && intersects[0].object != cube) {\n// \t\t\tactivePlane = intersects[0].object;\n// \t\t\tactivePlane.material.opacity = 0.2;\n// \t\t\tactivePlane.material.needsUpdate = true;\n// \t\t}\n// \t}\n\n// \tlet startTime = 0;\n// \tlet duration = 500;\n// \tlet oldPosition = new THREE.Vector3();\n// \tlet newPosition = new THREE.Vector3();\n// \tlet play = false;\n\n// \t// cubeRenderer.domElement.onclick = function(evt) {\n\n// \t// \tcubeRenderer.domElement.onmousemove(evt);\n\n// \t// \tif (!activePlane || hasMoved) {\n// \t// \t\treturn false;\n// \t// \t}\n\n// \t// \toldPosition.copy(camera.position);\n\n// \t// \tlet distance = camera.position.clone().sub(controller.target).length();\n// \t// \tnewPosition.copy(controller.target);\n\n// \t// \tif (activePlane.position.x !== 0) {\n// \t// \t\tnewPosition.x += activePlane.position.x < 0 ? -distance : distance;\n// \t// \t} else if (activePlane.position.y !== 0) {\n// \t// \t\tnewPosition.y += activePlane.position.y < 0 ? -distance : distance;\n// \t// \t} else if (activePlane.position.z !== 0) {\n// \t// \t\tnewPosition.z += activePlane.position.z < 0 ? -distance : distance;\n// \t// \t}\n\n// \t// \t//play = true;\n// \t// \t//startTime = Date.now();\n// \t// \tcamera.position.copy(newPosition);\n// \t// }\n\n// \tcubeRenderer.domElement.ontouchmove = function(e) {\n// \t\tlet rect = e.target.getBoundingClientRect();\n// \t\tlet x = e.targetTouches[0].pageX - rect.left;\n// \t\tlet y = e.targetTouches[0].pageY - rect.top;\n// \t\tcubeRenderer.domElement.onmousemove({\n// \t\t\toffsetX: x,\n// \t\t\toffsetY: y\n// \t\t});\n// \t}\n\n// \t// cubeRenderer.domElement.ontouchstart = function(e) {\n// \t// \tlet rect = e.target.getBoundingClientRect();\n// \t// \tlet x = e.targetTouches[0].pageX - rect.left;\n// \t// \tlet y = e.targetTouches[0].pageY - rect.top;\n// \t// \tcubeRenderer.domElement.onclick({\n// \t// \t\toffsetX: x,\n// \t// \t\toffsetY: y\n// \t// \t});\n// \t// }\n\n// \tViewerUI.fileInput.addEventListener('input', function(evt) {\n// \t\tlet file = evt.target.files[0];\n// \t\tif (file) {\n// \t\t\tshow(ViewerUI.loader);\n// \t\t\tViewerUI.loaderInfo.innerHTML = 'Reading file...';\n// \t\t\tlet reader = new FileReader();\n// \t\t\treader.onload = function(e) {\n// \t\t\t\tloadModel(e.target.result);\n// \t\t\t}\n// \t\t\treader.onerror = function(err) {\n// \t\t\t\tViewerUI.loaderInfo.innerHTML = 'Error reading file! See console for more info.';\n// \t\t\t\tconsole.error(err);\n// \t\t\t}\n// \t\t\treader.readAsDataURL(file);\n// \t\t}\n// \t});\n\n// \thide(ViewerUI.loader);\n\n// \tlet hasMoved = false;\n\n// \tfunction antiMoveOnDown(e) {\n// \t\thasMoved = false;\n// \t}\n// \tfunction antiMoveOnMove(e) {\n// \t\thasMoved = true;\n// \t}\n\n// \twindow.addEventListener('mousedown', antiMoveOnDown, false);\n// \twindow.addEventListener('mousemove', antiMoveOnMove, false);\n// \twindow.addEventListener('touchstart', antiMoveOnDown, false);\n// \twindow.addEventListener('touchmove', antiMoveOnMove, true);\n\n// \tlet showExploded = false;\n// \tlet explodeFactor = 0;\n// \tlet explodeFace = !true;\n\n// \ttoggleThrough(ViewerUI.explodeSliderWrapper, ViewerUI.toggleExplode, (bool) => {\n// \t\tif (!bool) {\n// \t\t\tresetExplode();\n// \t\t} else {\n// \t\t\texplodeFactor = ViewerUI.explodeSlider.value;\n// \t\t\texplode();\n// \t\t}\n// \t});\n\n// \tfunction resetExplode() {\n// \t\tlet temp = explodeFactor;\n// \t\tlet temp2 = explodeFace;\n// \t\texplodeFace = true;\n// \t\texplodeFactor = 0;\n// \t\texplode();\n// \t\texplodeFace = false;\n// \t\texplode();\n// \t\texplodeFactor = temp;\n// \t\texplodeFace = temp2;\n// \t}\n\n// \ttoggleThrough(ViewerUI.shareSidebar, ViewerUI.toggleShare);\n// \ttoggleThrough(ViewerUI.modelBrowser, ViewerUI.toggleModelBrowser);\n\n// \tViewerUI.explodeSlider.oninput = function() {\n// \t\texplodeFactor = this.value;\n// \t\texplode();\n// \t}\n\n// \tfunction explode() {\n// \t\tfor (let i = 0; i < loadedMeshes.length; i++) {\n\n// \t\t\tlet node = loadedMeshes[i];\n\n// \t\t\tif (explodeFace) {\n// \t\t\t\tlet defaultPositionArray = node.defaultPositionArray;\n// \t\t\t\tlet positionArray = node.geometry.attributes.position.array;\n// \t\t\t\tlet normalArray = node.geometry.attributes.normal.array;\n// \t\t\t\tlet indexArray = node.geometry.index.array;\n\n// \t\t\t\tfor (let j = 0; j < indexArray.length; j++) {\n\n// \t\t\t\t\tlet index = indexArray[j]\n// \t\t\t\t\tlet position = new THREE.Vector3(defaultPositionArray[index * 3], defaultPositionArray[index * 3 + 1], defaultPositionArray[index * 3 + 2]);\n// \t\t\t\t\tlet normal = new THREE.Vector3(normalArray[index * 3], normalArray[index * 3 + 1], normalArray[index * 3 + 2]);\n\n// \t\t\t\t\tposition.add(normal.multiplyScalar(explodeFactor));\n// \t\t\t\t\tpositionArray[index * 3] = position.x;\n// \t\t\t\t\tpositionArray[index * 3 + 1] = position.y;\n// \t\t\t\t\tpositionArray[index * 3 + 2] = position.z;\n\n// \t\t\t\t}\n\n// \t\t\t\tnode.geometry.attributes.position.needsUpdate = true;\n// \t\t\t\tnode.geometry.computeBoundingBox();\n// \t\t\t\tnode.geometry.computeBoundingSphere();\n// \t\t\t} else {\n// \t\t\t\tnode.position.copy(node.defaultPosition).add(node.defaultPosition.clone().normalize().multiplyScalar(explodeFactor));\n// \t\t\t}\n// \t\t}\n// \t}\n\n// \t// ViewerUI.toggleZoom.onclick = function() {\n// \t// \tsetZoomMode();\n// \t// \tsetItemSelected(selectedModeElement, false);\n// \t// \tselectedModeElement = this;\n// \t// \tsetItemSelected(this, true);\n// \t// }\n\n// \t// ViewerUI.togglePan.onclick = function() {\n// \t// \tsetPanMode();\n// \t// \tsetItemSelected(selectedModeElement, false);\n// \t// \tselectedModeElement = this;\n// \t// \tsetItemSelected(this, true);\n// \t// }\n\n// \t// ViewerUI.toggleOrbit.onclick = function() {\n// \t// \tsetOrbitMode();\n// \t// \tsetItemSelected(selectedModeElement, false);\n// \t// \tselectedModeElement = this;\n// \t// \tsetItemSelected(this, true);\n// \t// }\n\n// \t// render this later\n// \t// ViewerUI.toggleMeasure.onclick = function() {\n// \t// \tisInMeasureMode = !isInMeasureMode;\n// \t// \tif (!isInMeasureMode) {\n// \t// \t\tlineScene.remove.apply(lineScene, lineScene.children);\n// \t// \t\tspriteScene.remove.apply(spriteScene, spriteScene.children);\n// \t// \t}\n// \t// \tsetItemSelected(this, isInMeasureMode);\n// \t// }\n\n// \t// ViewerUI.resetBtn.onclick = ViewerUI.backToHome.onclick =function() {\n// \t// \tresetAll();\n// \t// }\n\n// \tfunction resetAll() {\n// \t\tcontroller.reset();\n// \t\tlineScene.remove.apply(lineScene, lineScene.children);\n// \t\tspriteScene.remove.apply(spriteScene, spriteScene.children);\n// \t\tisInMeasureMode = false;\n// \t\tsetItemSelected(ViewerUI.toggleMeasure, false);\n// \t\tViewerUI.explodeSliderWrapper.style.display = 'none';\n// \t\tViewerUI.explodeFace.checked = false;\n// \t\texplodeFace = false;\n// \t\tsetItemSelected(ViewerUI.toggleExplode, false);\n// \t\tresetExplode();\n// \t\tresetSelect();\n// \t}\n\n// \tfunction updateSelectDom(child) {\n// \t\tif (child.itemWrapper) {\n// \t\t\tif (child.isSelected) {\n// \t\t\t\tchild.itemWrapper.querySelector('.graph-name').style.color = '#03a9f4';\n// \t\t\t} else {\n// \t\t\t\tchild.itemWrapper.querySelector('.graph-name').style.color = 'inherit';\n// \t\t\t}\n// \t\t}\n// \t}\n\n// \tfunction setOrbitMode() {\n// \t\tcontroller.enableZoom = true;\n// \t\tcontroller.enablePan = true;\n// \t\tcontroller.enableRotate = true;\n// \t\tcontroller.mouseButtons = {\n// \t\t\tLEFT: THREE.MOUSE.ROTATE,\n// \t\t\tMIDDLE: THREE.MOUSE.DOLLY,\n// \t\t\tRIGHT: THREE.MOUSE.PAN\n// \t\t};\n// \t}\n\n// \tfunction setPanMode() {\n// \t\tcontroller.enableZoom = false;\n// \t\tcontroller.enablePan = true;\n// \t\tcontroller.enableRotate = false;\n// \t\tcontroller.mouseButtons = {\n// \t\t\tLEFT: THREE.MOUSE.PAN,\n// \t\t\tMIDDLE: THREE.MOUSE.PAN,\n// \t\t\tRIGHT: THREE.MOUSE.PAN\n// \t\t};\n// \t}\n\n// \tfunction setZoomMode() {\n// \t\tcontroller.enableZoom = true;\n// \t\tcontroller.enablePan = false;\n// \t\tcontroller.enableRotate = false;\n// \t\tcontroller.mouseButtons = {\n// \t\t\tLEFT: THREE.MOUSE.DOLLY,\n// \t\t\tMIDDLE: THREE.MOUSE.DOLLY,\n// \t\t\tRIGHT: THREE.MOUSE.DOLLY\n// \t\t};\n// \t}\n\n// \tlet wrapper = ViewerUI.canvasWrapper;\n// \tlet scene = new THREE.Scene();\n// \tlet camera = new THREE.PerspectiveCamera(70, wrapper.offsetWidth / wrapper.offsetHeight, 0.1, 1000);\n\n// \tlet renderer = new THREE.WebGLRenderer({\n// \t\tantialias: true,\n// \t\talpha: false\n// \t});\n\n// \trenderer.setClearColor(new THREE.Color(ViewerBG));\n// \trenderer.autoClear = false;\n// \trenderer.setPixelRatio(window.deivicePixelRatio);\n\n// \tlet isInMeasureMode = false;\n// \tlet lineScene = new THREE.Scene();\n// \tlet spriteScene = new THREE.Scene();\n\n// \tfunction makeCircleImage() {\n// \t\tlet canvas = document.createElement('canvas');\n// \t\tlet ctx = canvas.getContext('2d');\n// \t\tlet size = 32;\n// \t\tcanvas.width = size;\n// \t\tcanvas.height = size;\n\n// \t\tlet r = size * 0.8 / 2;\n// \t\tlet blur = size - r;\n\n// \t\tctx.shadowBlur = 5;\n// \t\tctx.shadowColor = '#555';\n\n// \t\tctx.fillStyle = '#fff';\n// \t\tctx.beginPath();\n// \t\tctx.arc(size / 2, size / 2, r, 0, Math.PI * 2);\n// \t\tctx.closePath();\n// \t\tctx.fill();\n\n// \t\tctx.shadowBlur = 0;\n// \t\tctx.fillStyle = '#009bff';\n// \t\tctx.beginPath();\n// \t\tctx.arc(size / 2, size / 2, r * 0.5, 0, Math.PI * 2);\n// \t\tctx.closePath();\n// \t\tctx.fill();\n\n// \t\treturn canvas;\n// \t}\n\n// \tlet circleTexture = new THREE.CanvasTexture(makeCircleImage())\n// \tlet circleMaterial = new THREE.SpriteMaterial({ \n// \t\tmap: circleTexture,\n// \t\tsizeAttenuation: false \n// \t});\n// \tlet circleSprite = new THREE.Sprite(circleMaterial);\n// \tcircleSprite.scale.setScalar(0.08);\n\n// \tlet lineMaterial = new THREE.LineBasicMaterial({\n// \t\tcolor: 0x009bff,\n// \t\tlinewidth: 10\n// \t});\n\n// \tlet activeLine = null;\n\n// \t// renderer.domElement.onclick = function(evt) {\n// \t// \tif (hasMoved) {\n// \t// \t\treturn false;\n// \t// \t}\n\n// \t// \tevt = evt || window.event;\n\n// \t// \tlet x = evt.offsetX;\n// \t// \tlet y = evt.offsetY;\n// \t// \tlet size = renderer.getSize(new THREE.Vector2());\n// \t// \tlet mouse = new THREE.Vector2(x / size.width * 2 - 1, -y / size.height * 2 + 1);\n\n// \t// \tlet raycaster = new THREE.Raycaster();\n// \t// \traycaster.setFromCamera(mouse, camera);\n// \t// \tlet intersects = raycaster.intersectObjects(loadedMeshes);\n\n// \t// \tif (!isInMeasureMode) {\n// \t// \t\tresetSelect();\n// \t// \t}\n\n// \t// \tif (intersects.length > 0) {\n// \t// \t\tif (isInMeasureMode) {\n// \t// \t\t\tlet point = intersects[0].point;\n// \t// \t\t\tif (!activeLine) {\n// \t// \t\t\t\tlet sprite1 = circleSprite.clone();\n// \t// \t\t\t\tlet sprite2 = circleSprite.clone();\n// \t// \t\t\t\tsprite1.position.copy(point.clone());\n// \t// \t\t\t\tsprite2.position.copy(point.clone());\n// \t// \t\t\t\tspriteScene.add(sprite1);\n// \t// \t\t\t\tspriteScene.add(sprite2);\n// \t// \t\t\t\tlet lineGeometry = new THREE.Geometry();\n// \t// \t\t\t\tlineGeometry.vertices.push(sprite1.position, sprite2.position);\n// \t// \t\t\t\tlet line = new THREE.Line(lineGeometry, lineMaterial);\n// \t// \t\t\t\tline.sprite1 = sprite1;\n// \t// \t\t\t\tline.sprite2 = sprite2;\n// \t// \t\t\t\tlineScene.add(line);\n// \t// \t\t\t\tactiveLine = line;\n// \t// \t\t\t} else {\n// \t// \t\t\t\tactiveLine.geometry.vertices[1].copy(point);\n// \t// \t\t\t\tactiveLine.geometry.verticesNeedUpdate = true;\n// \t// \t\t\t\tmakeDistanceSprite();\n// \t// \t\t\t\tactiveLine = null;\n// \t// \t\t\t}\n// \t// \t\t} else {\n// \t// \t\t\tlet mesh = intersects[0].object;\n// \t// \t\t\tmesh.isSelected = true;\n// \t// \t\t\tupdateMeshInteractionMaterial(mesh);\n// \t// \t\t}\n// \t// \t} else {\n// \t// \t\tif (isInMeasureMode) {\n// \t// \t\t\tif (activeLine) {\n// \t// \t\t\t\tlineScene.remove(activeLine);\n// \t// \t\t\t\tspriteScene.remove(activeLine.sprite1);\n// \t// \t\t\t\tspriteScene.remove(activeLine.sprite2);\n// \t// \t\t\t\tactiveLine = null;\n// \t// \t\t\t}\n// \t// \t\t}\n// \t// \t}\n// \t// }\n\n// \tfunction resetSelect() {\n// \t\tscene.traverse(child => {\n// \t\t\tchild.isSelected = false;\n// \t\t\tif (child.isMesh && child.material) {\t\n// \t\t\t\tupdateMeshInteractionMaterial(child);\n// \t\t\t}\n// \t\t\tupdateSelectDom(child);\n// \t\t});\n// \t}\n\n// \trenderer.domElement.onmousemove = function(evt) {\n// \t\tevt = evt || window.event;\n\n// \t\tif (!isInMeasureMode) {\n// \t\t\treturn;\n// \t\t}\n\n// \t\tlet x = evt.offsetX;\n// \t\tlet y = evt.offsetY;\n// \t\tlet size = renderer.getSize(new THREE.Vector2());\n// \t\tlet mouse = new THREE.Vector2(x / size.width * 2 - 1, -y / size.height * 2 + 1);\n\n// \t\tlet raycaster = new THREE.Raycaster();\n// \t\traycaster.setFromCamera(mouse, camera);\n// \t\tlet intersects = raycaster.intersectObjects(loadedMeshes);\n\n// \t\tif (isInMeasureMode && activeLine) {\n// \t\t\tif (intersects.length > 0) {\n// \t\t\t\tlet point = intersects[0].point;\n// \t\t\t\tactiveLine.geometry.vertices[1].copy(point);\n// \t\t\t\tactiveLine.geometry.verticesNeedUpdate = true;\n// \t\t\t} else {\n// \t\t\t\tactiveLine.geometry.vertices[1].copy(activeLine.geometry.vertices[0]);\n// \t\t\t\tactiveLine.geometry.verticesNeedUpdate = true;\n// \t\t\t}\n\n// \t\t}\n// \t}\n\n// \t/*renderer.domElement.ontouchmove = function(e) {\n// \t\tlet rect = e.target.getBoundingClientRect();\n// \t\tlet x = e.targetTouches[0].pageX - rect.left;\n// \t\tlet y = e.targetTouches[0].pageY - rect.top;\n// \t\trenderer.domElement.onmousemove({\n// \t\t\toffsetX: x,\n// \t\t\toffsetY: y\n// \t\t});\n// \t}*/\n\n// \t// renderer.domElement.ontouchstart = function(e) {\n// \t// \tlet rect = e.target.getBoundingClientRect();\n// \t// \tlet x = e.targetTouches[0].pageX - rect.left;\n// \t// \tlet y = e.targetTouches[0].pageY - rect.top;\n// \t// \trenderer.domElement.onclick({\n// \t// \t\toffsetX: x,\n// \t// \t\toffsetY: y\n// \t// \t});\n// \t// }\n\n// \tfunction makeDistanceSprite() {\n\n// \t\tlet canvas = document.createElement('canvas');\n// \t\tlet ctx = canvas.getContext('2d');\n// \t\tlet fontsize = 32;\n\n// \t\tctx.font = 'bolder ' + fontsize + 'px \"Open Sans\", Arial';\n// \t\tlet v = activeLine.geometry.vertices;\n// \t\tlet length = v[0].clone().sub(v[1]).length().toFixed(1);\n// \t\tlet text = '~ ' + length;\n// \t\tlet size = ctx.measureText(text);\n// \t\tlet paddingLeft = 20;\n// \t\tlet paddingTop = 10;\n// \t\tlet margin = 10;\n// \t\tcanvas.width = size.width + paddingLeft * 2 + margin * 2;\n// \t\tcanvas.height = fontsize + paddingTop * 2 + margin * 2;\n\n// \t\tctx.shadowBlur = 10;\n// \t\tctx.shadowColor = '#555';\n// \t\tctx.fillStyle = '#009bff';\n// \t\troundRect(ctx, margin, margin, canvas.width - margin * 2, canvas.height - margin * 2, 10);\n\n// \t\tctx.shadowBlur = 0;\n// \t\tctx.fillStyle = '#fff';\n// \t\tctx.textAlign = 'left';\n// \t\tctx.textBaseline = 'top';\n// \t\tctx.font = 'bolder ' + fontsize + 'px \"Open Sans\", Arial';\n// \t\tctx.fillText(text, paddingLeft + margin, paddingTop + margin);\n\n// \t\tlet texture = new THREE.CanvasTexture(canvas);\n// \t\tlet sprite = new THREE.Sprite(new THREE.SpriteMaterial({\n// \t\t\tmap: texture,\n// \t\t\tsizeAttenuation: false\n// \t\t}));\n\n// \t\tlet h = 0.7;\n// \t\tsprite.scale.set(0.002 * canvas.width, 0.0025 * canvas.height).multiplyScalar(h);\n\n// \t\tsprite.position.copy(v[0].clone().add(v[1]).multiplyScalar(0.5));\n// \t\tspriteScene.add(sprite);\n\n// \t}\n\n// \tfunction roundRect(ctx, x, y, w, h, r) { \n// \t\tctx.beginPath(); \n// \t\tctx.moveTo(x + r, y); \n// \t\tctx.lineTo(x + w - r, y); \n// \t\tctx.quadraticCurveTo(x + w, y, x + w, y + r); \n// \t\tctx.lineTo(x + w, y + h - r); \n// \t\tctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h); \n// \t\tctx.lineTo(x + r, y + h); \n// \t\tctx.quadraticCurveTo(x, y + h, x, y + h - r); \n// \t\tctx.lineTo(x, y + r); \n// \t\tctx.quadraticCurveTo(x, y, x + r, y); \n// \t\tctx.closePath(); \n// \t\tctx.fill();\n// \t} \n\n// \tfunction updateMeshInteractionMaterial(mesh) {\n// \t\tif (mesh.isHidden) {\n// \t\t\tmesh.interactionMaterial.color = hiddenColor;\n// \t\t\tmesh.interactionMaterial.opacity = hiddenAlpha;\n// \t\t} else {\n// \t\t\tmesh.interactionMaterial.opacity = 1;\n// \t\t}\n// \t\tif (mesh.isSelected) {\n// \t\t\tmesh.interactionMaterial.color = selectColor;\n// \t\t\tmesh.itemWrapper.querySelector('.graph-name').style.color = '#03a9f4';\n// \t\t} else {\n// \t\t\tmesh.itemWrapper.querySelector('.graph-name').style.color = 'inherit';\n// \t\t}\n// \t\tmesh.interactionMaterial.needsUpdate = true;\n// \t\tif (!mesh.isSelected && !mesh.isHidden) {\n// \t\t\tmesh.material = mesh.defaultMaterial;\n// \t\t} else {\n// \t\t\tmesh.material = mesh.interactionMaterial;\n// \t\t}\n// \t}\n\n// \tfunction onResize() {\n// \t\tlet width = wrapper.offsetWidth;\n// \t\tlet height = wrapper.offsetHeight;\n// \t\trenderer.setSize(width, height, false);\n// \t\tcamera.aspect = width / height;\n// \t\tcamera.updateProjectionMatrix();\n// \t}\n\n// \tonResize();\n\n// \twrapper.appendChild(renderer.domElement);\n// \twindow.addEventListener('resize', onResize, false);\n\n// \tlet gltfLoader = new THREE.GLTFLoader();\n// \tlet loadedScene = null;\n// \tlet loadedMeshes = [];\n\n// \tlet d = 5;\n\n// \tlet selectColor = new THREE.Color('#42006b');\n// \tlet hiddenColor = new THREE.Color('#555');\n// \tlet hiddenAlpha = 0.3;\n\n// \tlet interactionMaterial = new THREE.MeshPhongMaterial({\n// \t\ttransparent: true,\n// \t\tcolor: selectColor,\n// \t\tside: THREE.DoubleSide,\n// \t\tprecision: 'mediump'\n// \t});\n\n// \tfunction loadModel(url) {\n\n// \t\tresetAll();\n// \t\tif (loadedScene) {\n// \t\t\tscene.remove(loadedScene);\n// \t\t\tloadedScene = null;\n// \t\t\tloadedMeshes.length = 0;\n// \t\t}\n\n// \t\tshow(ViewerUI.loader);\n// \t\tViewerUI.modelBrowserContent.innerHTML = '';\n// \t\tViewerUI.loaderInfo.innerHTML = 'Loading model...';\n\n// \t\tgltfLoader.load(\n// \t\t\turl,\n// \t\t\tfunction onLoad(gltf) {\n\n// \t\t\t\tloadedScene = gltf.scene;\n// \t\t\t\tscene.add(gltf.scene);\n\n// \t\t\t\tgltf.scene = gltf.scene || gltf.scenes[0];\n\n// \t\t\t\tlet object = gltf.scene;\n\n// \t\t\t\tconst box = new THREE.Box3().setFromObject(object);\n// \t\t\t\tconst size = box.getSize(new THREE.Vector3()).length();\n// \t\t\t\tconst center = box.getCenter(new THREE.Vector3());\n\n// \t\t\t\tcontroller.reset();\n\n// \t\t\t\tobject.position.x += (object.position.x - center.x);\n// \t\t\t\tobject.position.y += (object.position.y - center.y);\n// \t\t\t\tobject.position.z += (object.position.z - center.z);\n// \t\t\t\tcontroller.maxDistance = size * 10;\n// \t\t\t\tcamera.near = size / 100;\n// \t\t\t\tcamera.far = size * 100;\n// \t\t\t\tcamera.updateProjectionMatrix();\n\n// \t\t\t\tcamera.position.copy(center);\n// \t\t\t\tcamera.position.x += size / 2.0;\n// \t\t\t\tcamera.position.y += size / 5.0;\n// \t\t\t\tcamera.position.z += size / 2.0;\n\n// \t\t\t\tdirectionalLight.position.setScalar(size);\n\n// \t\t\t\tcamera.lookAt(center);\n\n// \t\t\t\tcontroller.saveState();\n\n// \t\t\t\tgltf.scene.traverse((node) => {\n// \t\t\t\t\tif (node.isMesh && node.material) {\n// \t\t\t\t\t\tnode.geometry.computeBoundingBox();\n// \t\t\t\t\t\tnode.material.side = THREE.DoubleSide;\n// \t\t\t\t\t\tnode.material.precision = 'mediump';\n// \t\t\t\t\t\tnode.material.needsUpdate = true;\n// \t\t\t\t\t\tnode.interactionMaterial = interactionMaterial.clone();\n// \t\t\t\t\t\tnode.defaultMaterial = node.material;\n// \t\t\t\t\t\tnode.defaultPositionArray = Array.from(node.geometry.attributes.position.array);\n// \t\t\t\t\t\tnode.defaultPosition = node.position.clone();\n// \t\t\t\t\t\tloadedMeshes.push(node);\n// \t\t\t\t\t}\n// \t\t\t\t});\n\n// \t\t\t\tlet content = ViewerUI.modelBrowserContent;\n// \t\t\t\tlet counter = 0;\n// \t\t\t\tlet parentLevel = 0;\n\n// \t\t\t\tfunction makeSceneGraph(obj) {\n\n// \t\t\t\t\tif (obj.children.length === 0 && !obj.isMesh) {\n// \t\t\t\t\t\treturn;\n// \t\t\t\t\t}\n\n// \t\t\t\t\tlet itemWrapper = document.createElement('div');\n// \t\t\t\t\titemWrapper.classList.add('graph-item-wrapper');\n\n// \t\t\t\t\tlet item = document.createElement('div');\n// \t\t\t\t\titem.classList.add('graph-item');\n\n// \t\t\t\t\titemWrapper.appendChild(item);\n\n// \t\t\t\t\tcontent.appendChild(itemWrapper);\n// \t\t\t\t\tlet n = 0;\n// \t\t\t\t\tlet obj2 = obj;\n// \t\t\t\t\twhile (obj2 != gltf.scene) {\n// \t\t\t\t\t\tobj2 = obj2.parent;\n// \t\t\t\t\t\tn++;\n// \t\t\t\t\t}\n\n// \t\t\t\t\titem.style.paddingLeft = n * 1.5 + 'em';\n// \t\t\t\t\tobj.itemWrapper = itemWrapper;\n\n// \t\t\t\t\tlet left = document.createElement('div');\n// \t\t\t\t\tleft.classList.add('graph-left');\n// \t\t\t\t\tlet right = document.createElement('div');\n// \t\t\t\t\tright.classList.add('graph-right');\n// \t\t\t\t\titem.appendChild(left);\n// \t\t\t\t\titem.appendChild(right);\n\n// \t\t\t\t\tif (obj.children.length > 0) {\n\n// \t\t\t\t\t\tparentLevel++;\n// \t\t\t\t\t\tlet folder = document.createElement('div');\n\n// \t\t\t\t\t\tfolder.style.marginRight = '10px';\n// \t\t\t\t\t\tfolder.classList.add('graph-folder');\n// \t\t\t\t\t\tfolder.innerHTML = '<i class=\"fa fa-folder-open\"></i>';\n// \t\t\t\t\t\tleft.appendChild(folder);\n\n// \t\t\t\t\t\tobj.isFolderOpen = true;\n// \t\t\t\t\t\tobj.openFolder = function() {\n// \t\t\t\t\t\t\tfolder.innerHTML = obj.isFolderOpen ? '<i class=\"fa fa-folder-open\"></i>' :  '<i class=\"fa fa-folder\"></i>';\n// \t\t\t\t\t\t\tobj.traverse(child => {\n// \t\t\t\t\t\t\t\tif (obj === child) {\n// \t\t\t\t\t\t\t\t\treturn;\n// \t\t\t\t\t\t\t\t}\n// \t\t\t\t\t\t\t\tif (child.itemWrapper) {\n// \t\t\t\t\t\t\t\t\tif (child.parent.isFolderOpen && obj.isFolderOpen) {\n// \t\t\t\t\t\t\t\t\t\tchild.itemWrapper.style.display = 'block';\n// \t\t\t\t\t\t\t\t\t}\n// \t\t\t\t\t\t\t\t\tif (!obj.isFolderOpen) {\n// \t\t\t\t\t\t\t\t\t\tchild.itemWrapper.style.display = 'none';\n// \t\t\t\t\t\t\t\t\t}\n// \t\t\t\t\t\t\t\t}\n// \t\t\t\t\t\t\t});\n// \t\t\t\t\t\t}\n\n// \t\t\t\t\t\t// folder.onclick = () => {\n// \t\t\t\t\t\t// \tobj.isFolderOpen = !obj.isFolderOpen;\n// \t\t\t\t\t\t// \tobj.openFolder();\n// \t\t\t\t\t\t// }\n\n// \t\t\t\t\t\tfor (let i = 0; i < obj.children.length; i++) {\n// \t\t\t\t\t\t\tmakeSceneGraph(obj.children[i]);\n// \t\t\t\t\t\t}\n\n// \t\t\t\t\t}\n\n// \t\t\t\t\tlet name = document.createElement('div');\n// \t\t\t\t\tname.classList.add('graph-name');\n// \t\t\t\t\tname.innerHTML = obj.name || 'None';\n// \t\t\t\t\tleft.appendChild(name);\n\n// \t\t\t\t\t// name.onclick = function() {\n// \t\t\t\t\t// \tresetSelect();\n// \t\t\t\t\t// \tobj.traverse(child => {\t\n// \t\t\t\t\t// \t\tchild.isSelected = true;\n// \t\t\t\t\t// \t\tif (child.isMesh && child.material) {\n// \t\t\t\t\t// \t\t\tupdateMeshInteractionMaterial(child);\n// \t\t\t\t\t// \t\t}\n// \t\t\t\t\t// \t\tupdateSelectDom(child)\n// \t\t\t\t\t// \t});\n// \t\t\t\t\t// }\n\n// \t\t\t\t\tlet visible = document.createElement('div');\n// \t\t\t\t\tvisible.classList.add('graph-visible');\n// \t\t\t\t\tvisible.innerHTML = '<i class=\"fa fa-eye\"></i>';\n\n// \t\t\t\t\tobj.showMesh = function() {\n// \t\t\t\t\t\tvisible.innerHTML = obj.isMeshVisible ? '<i class=\"fa fa-eye\"></i>' : '<i class=\"fa fa-eye-slash\"></i>';\n// \t\t\t\t\t\tobj.traverse(child => {\n// \t\t\t\t\t\t\tif (child.itemWrapper) {\n// \t\t\t\t\t\t\t\tlet eye = child.itemWrapper.querySelector('.graph-visible');\n// \t\t\t\t\t\t\t\teye.innerHTML = obj.isMeshVisible ? '<i class=\"fa fa-eye\"></i>' : '<i class=\"fa fa-eye-slash\"></i>';\n// \t\t\t\t\t\t\t\teye.style.color = obj.isMeshVisible ? 'inherit' : 'rgba(0, 0, 0, 0.3)';\n// \t\t\t\t\t\t\t}\n// \t\t\t\t\t\t\tif (child.isMesh && child.material) {\n// \t\t\t\t\t\t\t\tchild.isHidden = !obj.isMeshVisible;\n// \t\t\t\t\t\t\t\tupdateMeshInteractionMaterial(child);\n// \t\t\t\t\t\t\t}\n// \t\t\t\t\t\t});\n// \t\t\t\t\t}\n\n// \t\t\t\t\tobj.isHidden = false;\n// \t\t\t\t\tobj.isSelected = false;\n// \t\t\t\t\tobj.isMeshVisible = true;\n// \t\t\t\t\t// visible.onclick = function() {\n// \t\t\t\t\t// \tobj.isMeshVisible = !obj.isMeshVisible;\n// \t\t\t\t\t// \tobj.showMesh();\n// \t\t\t\t\t// }\n\n// \t\t\t\t\tright.appendChild(visible)\n\n// \t\t\t\t}\n\n// \t\t\t\tmakeSceneGraph(gltf.scene)\n\n// \t\t\t\thide(ViewerUI.loader);\n\n// \t\t\t},\n// \t\t\tfunction onProgress(xhr) {\n// \t\t\t\tViewerUI.loaderInfo.innerHTML = Math.round(xhr.loaded / xhr.total * 100) + '% loaded';\n// \t\t\t},\n// \t\t\tfunction onError(err) {\n// \t\t\t\tViewerUI.loaderInfo.innerHTML = 'Error loading model! See console for more info.';\n// \t\t\t\tconsole.error('Error loading model!', err);\n// \t\t\t}\n// \t\t);\n\n// \t}\n\n// \tlet controller = new THREE.OrbitControls(camera, renderer.domElement);\n// \tcontroller.enabled = true;\n// \tcontroller.enableDamping = true;\n// \tcontroller.dampingFactor = 0.5;\n// \tcontroller.screenSpacePanning = true;\n\n// \tlet cubeController = new THREE.OrbitControls(camera, cubeRenderer.domElement);\n// \tcubeController.enablePan = false;\n// \tcubeController.enableZoom = false;\n// \tcubeController.rotateSpeed = 0.125;\n\n// \tlet selectedModeElement = ViewerUI.toggleOrbit;\n// \tsetOrbitMode();\n\n// \tcamera.position.z = d;\n// \tcamera.lookAt(scene.position);\n// \tcontroller.update();\n// \tcontroller.saveState();\n\n// \tlet ambientLight = new THREE.AmbientLight();\n// \tambientLight.intensity = 1;\n// \tscene.add(ambientLight);\n\n// \tlet directionalLight = new THREE.DirectionalLight();\n// \tdirectionalLight.position.set(200, 200, 200)\n// \tdirectionalLight.intensity = 0.5;\n// \tscene.add(directionalLight);\n\n// \t/*let light1 = new THREE.PointLight(0xffffff);\n// \tlight1.position.set(100, 100, 100);\n// \tscene.add(light1);\n\n// \tlet light2 = new THREE.PointLight(0xffffff);\n// \tlight2.position.set(100, 100, -100);\n// \tscene.add(light2);\n\n// \tlet light3 = new THREE.PointLight(0xffffff);\n// \tlight3.position.set(-100, 100, 100);\n// \tscene.add(light3);\n\n// \tlet light4 = new THREE.PointLight(0xffffff);\n// \tlight4.position.set(-100, 100, -100);\n// \tscene.add(light4);\n\n// \tlight1.intensity = light2.intensity = light3.intensity = light4.intensity = 0.3;*/\n\n// \tlet stop = false;\n\n// \tfunction renderAll() {\n\n// \t\trenderer.clear();\n// \t\trenderer.render(scene, camera);\n// \t\tupdateCubeCamera();\n// \t\tcubeRenderer.render(cubeScene, cubeCamera);\n\n// \t\trenderer.clearDepth();\n\n// \t\tif (isInMeasureMode) {\n// \t\t\trenderer.clearDepth();\n// \t\t\trenderer.render(lineScene, camera);\n// \t\t\trenderer.clearDepth();\n// \t\t\trenderer.render(spriteScene, camera);\n// \t\t}\n// \t}\n\n// \tfunction animate(time) {\n\n// \t\tif (stop) {\n// \t\t\treturn;\n// \t\t}\n\n// \t\tif (play) {\n// \t\t\tlet now = Date.now();\n// \t\t\tlet x = Math.min(1, (now - startTime) / duration);\n// \t\t\tcamera.position.copy(oldPosition).lerp(newPosition, x)\n// \t\t\tif (x === 1) {\n// \t\t\t\tplay = false;\n// \t\t\t}\n// \t\t}\n\n// \t\trequestAnimationFrame(animate);\n// \t\tcontroller.update();\n// \t\trenderAll();\n// \t}\n\n// \trequestAnimationFrame(animate);\n\n// \treturn {\n// \t\tloadModel: loadModel\n// \t};\n\n// }\n\n// function draggable(ele, toggleEle) {\n\n// \tlet startX = 0;\n// \tlet startY = 0;\n\n// \tfunction onMouseDown(evt) {\n// \t\tevt = evt || window.event;\n// \t\tstartDrag(evt.clientX, evt.clientY);\n// \t\twindow.addEventListener('mousemove', onMouseMove, true);\n// \t}\n\n// \tfunction onMouseMove(evt) {\n// \t\tevt = evt || window.event;\n// \t\tlet newX = evt.clientX;\n// \t\tlet newY = evt.clientY;\n// \t\tmoveDrag(newX, newY);\n// \t}\n\n// \tfunction onMouseUp() {\n// \t\twindow.removeEventListener('mousemove', onMouseMove, true);\n// \t}\n\n// \tfunction startDrag(x, y) {\n// \t\tstartX = x;\n// \t\tstartY = y;\n// \t}\n\n// \tfunction moveDrag(newX, newY) {\n\n// \t\tlet deltaX = newX - startX;\n// \t\tlet deltaY = newY - startY;\n\n// \t\tstartX = newX;\n// \t\tstartY = newY;\n\n// \t\tlet x = ele.offsetLeft + deltaX;\n// \t\tlet y = ele.offsetTop + deltaY;\n// \t\tx < 0 && (x = 0);\n// \t\ty < 0 && (y = 0);\n// \t\tlet w = ele.parentNode.offsetWidth - ele.offsetWidth;\n// \t\tlet h = ele.parentNode.offsetHeight - ele.offsetHeight;\n// \t\tx > w && (x = w);\n// \t\ty > h && (y = h);\n\n// \t\tele.style.left = x + 'px';\n// \t\tele.style.top = y + 'px';\n\n// \t}\n\n// \ttoggleEle.addEventListener('mousedown', onMouseDown, true);\n// \twindow.addEventListener('mouseup', onMouseUp, true);\n\n// }","map":{"version":3,"names":[],"sources":["/Users/rahilshaik/parch/par.ch-web/src/components/model-viewer/model-viewer-component.js"],"sourcesContent":["// import * as THREE from 'three';\n\n\n// // const scene = new THREE.Scene();\n// // const camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );\n// const ViewerBG = '#eee';\n// const ViewerUI = {\n// \tcanvasWrapper: document.getElementById('viewerCanvasWrapper'),\n// \tcubeWrapper: document.getElementById('orientCubeWrapper'),\n// \ttoggleZoom: document.getElementById('toggleZoom'),\n// \ttogglePan: document.getElementById('togglePan'),\n// \ttoggleOrbit: document.getElementById('toggleOrbit'),\n// \tresetBtn: document.getElementById('resetBtn'),\n// \ttoggleModelBrowser: document.getElementById('toggleModelBrowser'),\n// \tmodelBrowser: document.getElementById('modelBrowser'),\n// \tmodelBrowserContent: document.getElementById('modelBrowserContent'),\n// \tfileInput: document.getElementById('fileInput'),\n// \texplodeSliderWrapper: document.getElementById('explodeSliderWrapper'),\n// \texplodeSlider: document.getElementById('explodeSlider'),\n// \ttoggleExplode: document.getElementById('toggleExplode'),\n// \ttoggleShare: document.getElementById('toggleShare'),\n// \tshareSidebar: document.getElementById('shareSidebar'),\n// \tloader: document.getElementById('loader'),\n// \ttoggleMeasure: document.getElementById('toggleMeasure'),\n// \tloaderInfo: document.getElementById('loaderInfo'),\n// \tbackToHome: document.getElementById('backToHome'),\n// \twebglContainer: document.getElementById('webglContainer'),\n// \tdownloadScreen: document.getElementById('downloadScreen'),\n// \texplodeFace: document.getElementById('explodeFace')\n// };\n\n// function setItemSelected(ele, bool) {\n// \tif (bool) {\n// \t\tele.classList.add('item-selected');\n// \t} else {\n// \t\tele.classList.remove('item-selected');\n// \t}\n// }\n\n// function toggle(ele) {\n// \tif (ele.getBoundingClientRect().height > 0) {\n// \t\tele.style.display = 'none';\n// \t\treturn false;\n// \t} else {\n// \t\tele.style.display = 'block';\n// \t\treturn true;\n// \t}\n// }\n\n// function toggleThrough(ele, through, cb, selected=true) {\n// \t// through.onclick = () => {\n// \t// \tlet bool = toggle(ele);\n// \t// \tselected && setItemSelected(through, bool);\n// \t// \tcb && cb(bool);\n// \t// }\n// }\n\n// function show(ele) {\n// \tele.style.display = 'block';\n// }\n\n// function hide(ele) {\n// \tele.style.display = 'none';\n// }\n\n// export default function ModelViewer() {\n\n// \t// ViewerUI.downloadScreen.onclick = function() {\n// \t// \tconst canvas = renderer.domElement;\n// \t// \trenderAll();\n// \t// \tconst image = canvas.toDataURL(\"image/png\");\n// \t// \tconst a = document.createElement(\"a\");\n// \t// \ta.href = image.replace(/^data:image\\/[^;]/, 'data:application/octet-stream');\n// \t// \ta.download = \"image.png\"\n// \t// \ta.click();\n// \t// }\n\n// \t// ViewerUI.explodeFace.onclick = function() {\n// \t// \texplodeFace = this.checked;\n// \t// \tresetExplode();\n// \t// \texplode();\n// \t// }\n\n// \tlet cubeCameraDistance = 1.75;\n\n// \tlet cubeWrapper = ViewerUI.cubeWrapper;\n// \tlet cubeScene = new THREE.Scene();\n// \tlet cubeCamera = new THREE.PerspectiveCamera(70, cubeWrapper.offsetWidth / cubeWrapper.offsetHeight, 0.1, 100);\n// \tlet cubeRenderer = new THREE.WebGLRenderer({\n// \t\talpha: true,\n// \t\tantialias: true,\n// \t\tpreserveDrawingBuffer: true\n// \t}); \n\n// \tcubeRenderer.setSize(cubeWrapper.offsetWidth, cubeWrapper.offsetHeight);\n// \tcubeRenderer.setPixelRatio(window.deivicePixelRatio);\n\n// \tcubeWrapper.appendChild(cubeRenderer.domElement);\n\n// \tlet materials = [];\n// \tlet texts = ['RIGHT', 'LEFT', 'TOP', 'BOTTOM', 'FRONT', 'BACK'];\n\n// \tlet textureLoader = new THREE.TextureLoader();\n// \tlet canvas = document.createElement('canvas');\n// \tlet ctx = canvas.getContext('2d');\n\t\n// \tlet size = 64;\n// \tcanvas.width = size;\n// \tcanvas.height = size;\n\n// \tctx.font = 'bolder 12px \"Open sans\", Arial';\n// \tctx.textBaseline = 'middle';\n// \tctx.textAlign = 'center';\n\n// \tlet mainColor = '#fff';\n// \tlet otherColor = '#ccc';\n\n// \tlet bg = ctx.createLinearGradient(0, 0, 0, size);\n// \tbg.addColorStop(0, mainColor);\n// \tbg.addColorStop(1,  otherColor);\n\n// \tfor (let i = 0; i < 6; i++) {\n// \t\tif (texts[i] == 'TOP') {\n// \t\t\tctx.fillStyle = mainColor;\n// \t\t} else if (texts[i] == 'BOTTOM') {\n// \t\t\tctx.fillStyle = otherColor;\n// \t\t} else {\n// \t\t\tctx.fillStyle = bg;\n// \t\t}\n// \t\tctx.fillRect(0, 0, size, size);\n// \t\tctx.strokeStyle = '#aaa';\n// \t\tctx.setLineDash([8, 8]);\n// \t\tctx.lineWidth = 4;\n// \t\tctx.strokeRect(0, 0, size, size);\n// \t\tctx.fillStyle = '#999';\n// \t\tctx.fillText(texts[i], size / 2, size / 2);\n// \t\tmaterials[i] = new THREE.MeshBasicMaterial({\n// \t\t\tmap: textureLoader.load(canvas.toDataURL())\n// \t\t});\n// \t}\n\n// \tlet planes = [];\n\n// \tlet planeMaterial = new THREE.MeshBasicMaterial({\n// \t\tside: THREE.DoubleSide,\n// \t\tcolor: 0x00c0ff,\n// \t\ttransparent: true,\n// \t\topacity: 0,\n// \t\tdepthTest: false\n// \t});\n// \tlet planeSize = 0.7;\n// \tlet planeGeometry = new THREE.PlaneGeometry(planeSize, planeSize);\n\n// \tlet a = 0.51;\n\n// \tlet plane1 = new THREE.Mesh(planeGeometry, planeMaterial.clone());\n// \tplane1.position.z = a;\n// \tcubeScene.add(plane1);\n// \tplanes.push(plane1);\n\n// \tlet plane2 = new THREE.Mesh(planeGeometry, planeMaterial.clone());\n// \tplane2.position.z = -a;\n// \tcubeScene.add(plane2);\n// \tplanes.push(plane2);\n\n// \tlet plane3 = new THREE.Mesh(planeGeometry, planeMaterial.clone());\n// \tplane3.rotation.y = Math.PI / 2;\n// \tplane3.position.x = a;\n// \tcubeScene.add(plane3);\n// \tplanes.push(plane3);\n\n// \tlet plane4 = new THREE.Mesh(planeGeometry, planeMaterial.clone());\n// \tplane4.rotation.y = Math.PI / 2;\n// \tplane4.position.x = -a;\n// \tcubeScene.add(plane4);\n// \tplanes.push(plane4);\n\n// \tlet plane5 = new THREE.Mesh(planeGeometry, planeMaterial.clone());\n// \tplane5.rotation.x = Math.PI / 2;\n// \tplane5.position.y = a;\n// \tcubeScene.add(plane5);\n// \tplanes.push(plane5);\n\n// \tlet plane6 = new THREE.Mesh(planeGeometry, planeMaterial.clone());\n// \tplane6.rotation.x = Math.PI / 2;\n// \tplane6.position.y = -a;\n// \tcubeScene.add(plane6);\n// \tplanes.push(plane6);\n\n// \tlet groundMaterial = new THREE.MeshBasicMaterial({\n// \t\tcolor: 0xaaaaaa\n// \t});\n// \tlet groundGeometry = new THREE.PlaneGeometry(1, 1);\n// \tlet groundPlane = new THREE.Mesh(groundGeometry, groundMaterial);\n// \tgroundPlane.rotation.x = -Math.PI / 2;\n// \tgroundPlane.position.y = -0.6;\n\n// \tcubeScene.add(groundPlane);\n\n// \tlet cube = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 1), materials);\n// \tcubeScene.add(cube);\n\n// \tfunction updateCubeCamera() {\n// \t\tcubeCamera.rotation.copy(camera.rotation);\n// \t\tlet dir = camera.position.clone().sub(controller.target).normalize();\n// \t\tcubeCamera.position.copy(dir.multiplyScalar(cubeCameraDistance));\n// \t}\n\n// \tlet activePlane = null;\n\n// \tcubeRenderer.domElement.onmousemove = function(evt) {\n\n// \t\tif (activePlane) {\n// \t\t\tactivePlane.material.opacity = 0;\n// \t\t\tactivePlane.material.needsUpdate = true;\n// \t\t\tactivePlane = null;\n// \t\t}\n\n// \t\tlet x = evt.offsetX;\n// \t\tlet y = evt.offsetY;\n// \t\tlet size = cubeRenderer.getSize(new THREE.Vector2());\n// \t\tlet mouse = new THREE.Vector2(x / size.width * 2 - 1, -y / size.height * 2 + 1);\n\t\t\n// \t\tlet raycaster = new THREE.Raycaster();\n// \t\traycaster.setFromCamera(mouse, cubeCamera);\n// \t\tlet intersects = raycaster.intersectObjects(planes.concat(cube));\n\n// \t\tif (intersects.length > 0 && intersects[0].object != cube) {\n// \t\t\tactivePlane = intersects[0].object;\n// \t\t\tactivePlane.material.opacity = 0.2;\n// \t\t\tactivePlane.material.needsUpdate = true;\n// \t\t}\n// \t}\n\n// \tlet startTime = 0;\n// \tlet duration = 500;\n// \tlet oldPosition = new THREE.Vector3();\n// \tlet newPosition = new THREE.Vector3();\n// \tlet play = false;\n\n// \t// cubeRenderer.domElement.onclick = function(evt) {\n\n// \t// \tcubeRenderer.domElement.onmousemove(evt);\n\n// \t// \tif (!activePlane || hasMoved) {\n// \t// \t\treturn false;\n// \t// \t}\n\n// \t// \toldPosition.copy(camera.position);\n\n// \t// \tlet distance = camera.position.clone().sub(controller.target).length();\n// \t// \tnewPosition.copy(controller.target);\n\n// \t// \tif (activePlane.position.x !== 0) {\n// \t// \t\tnewPosition.x += activePlane.position.x < 0 ? -distance : distance;\n// \t// \t} else if (activePlane.position.y !== 0) {\n// \t// \t\tnewPosition.y += activePlane.position.y < 0 ? -distance : distance;\n// \t// \t} else if (activePlane.position.z !== 0) {\n// \t// \t\tnewPosition.z += activePlane.position.z < 0 ? -distance : distance;\n// \t// \t}\n\n// \t// \t//play = true;\n// \t// \t//startTime = Date.now();\n// \t// \tcamera.position.copy(newPosition);\n// \t// }\n\n// \tcubeRenderer.domElement.ontouchmove = function(e) {\n// \t\tlet rect = e.target.getBoundingClientRect();\n// \t\tlet x = e.targetTouches[0].pageX - rect.left;\n// \t\tlet y = e.targetTouches[0].pageY - rect.top;\n// \t\tcubeRenderer.domElement.onmousemove({\n// \t\t\toffsetX: x,\n// \t\t\toffsetY: y\n// \t\t});\n// \t}\n\n// \t// cubeRenderer.domElement.ontouchstart = function(e) {\n// \t// \tlet rect = e.target.getBoundingClientRect();\n// \t// \tlet x = e.targetTouches[0].pageX - rect.left;\n// \t// \tlet y = e.targetTouches[0].pageY - rect.top;\n// \t// \tcubeRenderer.domElement.onclick({\n// \t// \t\toffsetX: x,\n// \t// \t\toffsetY: y\n// \t// \t});\n// \t// }\n\n// \tViewerUI.fileInput.addEventListener('input', function(evt) {\n// \t\tlet file = evt.target.files[0];\n// \t\tif (file) {\n// \t\t\tshow(ViewerUI.loader);\n// \t\t\tViewerUI.loaderInfo.innerHTML = 'Reading file...';\n// \t\t\tlet reader = new FileReader();\n// \t\t\treader.onload = function(e) {\n// \t\t\t\tloadModel(e.target.result);\n// \t\t\t}\n// \t\t\treader.onerror = function(err) {\n// \t\t\t\tViewerUI.loaderInfo.innerHTML = 'Error reading file! See console for more info.';\n// \t\t\t\tconsole.error(err);\n// \t\t\t}\n// \t\t\treader.readAsDataURL(file);\n// \t\t}\n// \t});\n\t\n// \thide(ViewerUI.loader);\n\n// \tlet hasMoved = false;\n\n// \tfunction antiMoveOnDown(e) {\n// \t\thasMoved = false;\n// \t}\n// \tfunction antiMoveOnMove(e) {\n// \t\thasMoved = true;\n// \t}\n\t\n// \twindow.addEventListener('mousedown', antiMoveOnDown, false);\n// \twindow.addEventListener('mousemove', antiMoveOnMove, false);\n// \twindow.addEventListener('touchstart', antiMoveOnDown, false);\n// \twindow.addEventListener('touchmove', antiMoveOnMove, true);\n\t\n// \tlet showExploded = false;\n// \tlet explodeFactor = 0;\n// \tlet explodeFace = !true;\n\t\n// \ttoggleThrough(ViewerUI.explodeSliderWrapper, ViewerUI.toggleExplode, (bool) => {\n// \t\tif (!bool) {\n// \t\t\tresetExplode();\n// \t\t} else {\n// \t\t\texplodeFactor = ViewerUI.explodeSlider.value;\n// \t\t\texplode();\n// \t\t}\n// \t});\n\t\n// \tfunction resetExplode() {\n// \t\tlet temp = explodeFactor;\n// \t\tlet temp2 = explodeFace;\n// \t\texplodeFace = true;\n// \t\texplodeFactor = 0;\n// \t\texplode();\n// \t\texplodeFace = false;\n// \t\texplode();\n// \t\texplodeFactor = temp;\n// \t\texplodeFace = temp2;\n// \t}\n\t\n// \ttoggleThrough(ViewerUI.shareSidebar, ViewerUI.toggleShare);\n// \ttoggleThrough(ViewerUI.modelBrowser, ViewerUI.toggleModelBrowser);\n\t\n// \tViewerUI.explodeSlider.oninput = function() {\n// \t\texplodeFactor = this.value;\n// \t\texplode();\n// \t}\n\t\n// \tfunction explode() {\n// \t\tfor (let i = 0; i < loadedMeshes.length; i++) {\n\t\t\t\n// \t\t\tlet node = loadedMeshes[i];\n\n// \t\t\tif (explodeFace) {\n// \t\t\t\tlet defaultPositionArray = node.defaultPositionArray;\n// \t\t\t\tlet positionArray = node.geometry.attributes.position.array;\n// \t\t\t\tlet normalArray = node.geometry.attributes.normal.array;\n// \t\t\t\tlet indexArray = node.geometry.index.array;\n\t\t\t\t\n// \t\t\t\tfor (let j = 0; j < indexArray.length; j++) {\n\t\t\t\t\t\n// \t\t\t\t\tlet index = indexArray[j]\n// \t\t\t\t\tlet position = new THREE.Vector3(defaultPositionArray[index * 3], defaultPositionArray[index * 3 + 1], defaultPositionArray[index * 3 + 2]);\n// \t\t\t\t\tlet normal = new THREE.Vector3(normalArray[index * 3], normalArray[index * 3 + 1], normalArray[index * 3 + 2]);\n\t\t\t\t\t\n// \t\t\t\t\tposition.add(normal.multiplyScalar(explodeFactor));\n// \t\t\t\t\tpositionArray[index * 3] = position.x;\n// \t\t\t\t\tpositionArray[index * 3 + 1] = position.y;\n// \t\t\t\t\tpositionArray[index * 3 + 2] = position.z;\n\t\t\t\t\t\n// \t\t\t\t}\n\t\t\t\t\n// \t\t\t\tnode.geometry.attributes.position.needsUpdate = true;\n// \t\t\t\tnode.geometry.computeBoundingBox();\n// \t\t\t\tnode.geometry.computeBoundingSphere();\n// \t\t\t} else {\n// \t\t\t\tnode.position.copy(node.defaultPosition).add(node.defaultPosition.clone().normalize().multiplyScalar(explodeFactor));\n// \t\t\t}\n// \t\t}\n// \t}\n\t\n// \t// ViewerUI.toggleZoom.onclick = function() {\n// \t// \tsetZoomMode();\n// \t// \tsetItemSelected(selectedModeElement, false);\n// \t// \tselectedModeElement = this;\n// \t// \tsetItemSelected(this, true);\n// \t// }\n\t\n// \t// ViewerUI.togglePan.onclick = function() {\n// \t// \tsetPanMode();\n// \t// \tsetItemSelected(selectedModeElement, false);\n// \t// \tselectedModeElement = this;\n// \t// \tsetItemSelected(this, true);\n// \t// }\n\t\n// \t// ViewerUI.toggleOrbit.onclick = function() {\n// \t// \tsetOrbitMode();\n// \t// \tsetItemSelected(selectedModeElement, false);\n// \t// \tselectedModeElement = this;\n// \t// \tsetItemSelected(this, true);\n// \t// }\n\t\n// \t// render this later\n// \t// ViewerUI.toggleMeasure.onclick = function() {\n// \t// \tisInMeasureMode = !isInMeasureMode;\n// \t// \tif (!isInMeasureMode) {\n// \t// \t\tlineScene.remove.apply(lineScene, lineScene.children);\n// \t// \t\tspriteScene.remove.apply(spriteScene, spriteScene.children);\n// \t// \t}\n// \t// \tsetItemSelected(this, isInMeasureMode);\n// \t// }\n\t\n// \t// ViewerUI.resetBtn.onclick = ViewerUI.backToHome.onclick =function() {\n// \t// \tresetAll();\n// \t// }\n\n// \tfunction resetAll() {\n// \t\tcontroller.reset();\n// \t\tlineScene.remove.apply(lineScene, lineScene.children);\n// \t\tspriteScene.remove.apply(spriteScene, spriteScene.children);\n// \t\tisInMeasureMode = false;\n// \t\tsetItemSelected(ViewerUI.toggleMeasure, false);\n// \t\tViewerUI.explodeSliderWrapper.style.display = 'none';\n// \t\tViewerUI.explodeFace.checked = false;\n// \t\texplodeFace = false;\n// \t\tsetItemSelected(ViewerUI.toggleExplode, false);\n// \t\tresetExplode();\n// \t\tresetSelect();\n// \t}\n\n// \tfunction updateSelectDom(child) {\n// \t\tif (child.itemWrapper) {\n// \t\t\tif (child.isSelected) {\n// \t\t\t\tchild.itemWrapper.querySelector('.graph-name').style.color = '#03a9f4';\n// \t\t\t} else {\n// \t\t\t\tchild.itemWrapper.querySelector('.graph-name').style.color = 'inherit';\n// \t\t\t}\n// \t\t}\n// \t}\n\t\n// \tfunction setOrbitMode() {\n// \t\tcontroller.enableZoom = true;\n// \t\tcontroller.enablePan = true;\n// \t\tcontroller.enableRotate = true;\n// \t\tcontroller.mouseButtons = {\n// \t\t\tLEFT: THREE.MOUSE.ROTATE,\n// \t\t\tMIDDLE: THREE.MOUSE.DOLLY,\n// \t\t\tRIGHT: THREE.MOUSE.PAN\n// \t\t};\n// \t}\n\t\n// \tfunction setPanMode() {\n// \t\tcontroller.enableZoom = false;\n// \t\tcontroller.enablePan = true;\n// \t\tcontroller.enableRotate = false;\n// \t\tcontroller.mouseButtons = {\n// \t\t\tLEFT: THREE.MOUSE.PAN,\n// \t\t\tMIDDLE: THREE.MOUSE.PAN,\n// \t\t\tRIGHT: THREE.MOUSE.PAN\n// \t\t};\n// \t}\n\t\n// \tfunction setZoomMode() {\n// \t\tcontroller.enableZoom = true;\n// \t\tcontroller.enablePan = false;\n// \t\tcontroller.enableRotate = false;\n// \t\tcontroller.mouseButtons = {\n// \t\t\tLEFT: THREE.MOUSE.DOLLY,\n// \t\t\tMIDDLE: THREE.MOUSE.DOLLY,\n// \t\t\tRIGHT: THREE.MOUSE.DOLLY\n// \t\t};\n// \t}\n\t\n// \tlet wrapper = ViewerUI.canvasWrapper;\n// \tlet scene = new THREE.Scene();\n// \tlet camera = new THREE.PerspectiveCamera(70, wrapper.offsetWidth / wrapper.offsetHeight, 0.1, 1000);\n\t\n// \tlet renderer = new THREE.WebGLRenderer({\n// \t\tantialias: true,\n// \t\talpha: false\n// \t});\n\t\n// \trenderer.setClearColor(new THREE.Color(ViewerBG));\n// \trenderer.autoClear = false;\n// \trenderer.setPixelRatio(window.deivicePixelRatio);\n\n// \tlet isInMeasureMode = false;\n// \tlet lineScene = new THREE.Scene();\n// \tlet spriteScene = new THREE.Scene();\n\n// \tfunction makeCircleImage() {\n// \t\tlet canvas = document.createElement('canvas');\n// \t\tlet ctx = canvas.getContext('2d');\n// \t\tlet size = 32;\n// \t\tcanvas.width = size;\n// \t\tcanvas.height = size;\n\n// \t\tlet r = size * 0.8 / 2;\n// \t\tlet blur = size - r;\n\t\t\n// \t\tctx.shadowBlur = 5;\n// \t\tctx.shadowColor = '#555';\n\n// \t\tctx.fillStyle = '#fff';\n// \t\tctx.beginPath();\n// \t\tctx.arc(size / 2, size / 2, r, 0, Math.PI * 2);\n// \t\tctx.closePath();\n// \t\tctx.fill();\n\n// \t\tctx.shadowBlur = 0;\n// \t\tctx.fillStyle = '#009bff';\n// \t\tctx.beginPath();\n// \t\tctx.arc(size / 2, size / 2, r * 0.5, 0, Math.PI * 2);\n// \t\tctx.closePath();\n// \t\tctx.fill();\n\n// \t\treturn canvas;\n// \t}\n\n// \tlet circleTexture = new THREE.CanvasTexture(makeCircleImage())\n// \tlet circleMaterial = new THREE.SpriteMaterial({ \n// \t\tmap: circleTexture,\n// \t\tsizeAttenuation: false \n// \t});\n// \tlet circleSprite = new THREE.Sprite(circleMaterial);\n// \tcircleSprite.scale.setScalar(0.08);\n\n// \tlet lineMaterial = new THREE.LineBasicMaterial({\n// \t\tcolor: 0x009bff,\n// \t\tlinewidth: 10\n// \t});\n\n// \tlet activeLine = null;\n\n// \t// renderer.domElement.onclick = function(evt) {\n// \t// \tif (hasMoved) {\n// \t// \t\treturn false;\n// \t// \t}\n\t\t\n// \t// \tevt = evt || window.event;\n\t\t\n// \t// \tlet x = evt.offsetX;\n// \t// \tlet y = evt.offsetY;\n// \t// \tlet size = renderer.getSize(new THREE.Vector2());\n// \t// \tlet mouse = new THREE.Vector2(x / size.width * 2 - 1, -y / size.height * 2 + 1);\n\t\t\n// \t// \tlet raycaster = new THREE.Raycaster();\n// \t// \traycaster.setFromCamera(mouse, camera);\n// \t// \tlet intersects = raycaster.intersectObjects(loadedMeshes);\n\t\t\n// \t// \tif (!isInMeasureMode) {\n// \t// \t\tresetSelect();\n// \t// \t}\n\t\t\n// \t// \tif (intersects.length > 0) {\n// \t// \t\tif (isInMeasureMode) {\n// \t// \t\t\tlet point = intersects[0].point;\n// \t// \t\t\tif (!activeLine) {\n// \t// \t\t\t\tlet sprite1 = circleSprite.clone();\n// \t// \t\t\t\tlet sprite2 = circleSprite.clone();\n// \t// \t\t\t\tsprite1.position.copy(point.clone());\n// \t// \t\t\t\tsprite2.position.copy(point.clone());\n// \t// \t\t\t\tspriteScene.add(sprite1);\n// \t// \t\t\t\tspriteScene.add(sprite2);\n// \t// \t\t\t\tlet lineGeometry = new THREE.Geometry();\n// \t// \t\t\t\tlineGeometry.vertices.push(sprite1.position, sprite2.position);\n// \t// \t\t\t\tlet line = new THREE.Line(lineGeometry, lineMaterial);\n// \t// \t\t\t\tline.sprite1 = sprite1;\n// \t// \t\t\t\tline.sprite2 = sprite2;\n// \t// \t\t\t\tlineScene.add(line);\n// \t// \t\t\t\tactiveLine = line;\n// \t// \t\t\t} else {\n// \t// \t\t\t\tactiveLine.geometry.vertices[1].copy(point);\n// \t// \t\t\t\tactiveLine.geometry.verticesNeedUpdate = true;\n// \t// \t\t\t\tmakeDistanceSprite();\n// \t// \t\t\t\tactiveLine = null;\n// \t// \t\t\t}\n// \t// \t\t} else {\n// \t// \t\t\tlet mesh = intersects[0].object;\n// \t// \t\t\tmesh.isSelected = true;\n// \t// \t\t\tupdateMeshInteractionMaterial(mesh);\n// \t// \t\t}\n// \t// \t} else {\n// \t// \t\tif (isInMeasureMode) {\n// \t// \t\t\tif (activeLine) {\n// \t// \t\t\t\tlineScene.remove(activeLine);\n// \t// \t\t\t\tspriteScene.remove(activeLine.sprite1);\n// \t// \t\t\t\tspriteScene.remove(activeLine.sprite2);\n// \t// \t\t\t\tactiveLine = null;\n// \t// \t\t\t}\n// \t// \t\t}\n// \t// \t}\n// \t// }\n\t\n// \tfunction resetSelect() {\n// \t\tscene.traverse(child => {\n// \t\t\tchild.isSelected = false;\n// \t\t\tif (child.isMesh && child.material) {\t\n// \t\t\t\tupdateMeshInteractionMaterial(child);\n// \t\t\t}\n// \t\t\tupdateSelectDom(child);\n// \t\t});\n// \t}\n\t\t\n\n// \trenderer.domElement.onmousemove = function(evt) {\n// \t\tevt = evt || window.event;\n\n// \t\tif (!isInMeasureMode) {\n// \t\t\treturn;\n// \t\t}\n\t\t\n// \t\tlet x = evt.offsetX;\n// \t\tlet y = evt.offsetY;\n// \t\tlet size = renderer.getSize(new THREE.Vector2());\n// \t\tlet mouse = new THREE.Vector2(x / size.width * 2 - 1, -y / size.height * 2 + 1);\n\t\t\n// \t\tlet raycaster = new THREE.Raycaster();\n// \t\traycaster.setFromCamera(mouse, camera);\n// \t\tlet intersects = raycaster.intersectObjects(loadedMeshes);\n\t\t\n// \t\tif (isInMeasureMode && activeLine) {\n// \t\t\tif (intersects.length > 0) {\n// \t\t\t\tlet point = intersects[0].point;\n// \t\t\t\tactiveLine.geometry.vertices[1].copy(point);\n// \t\t\t\tactiveLine.geometry.verticesNeedUpdate = true;\n// \t\t\t} else {\n// \t\t\t\tactiveLine.geometry.vertices[1].copy(activeLine.geometry.vertices[0]);\n// \t\t\t\tactiveLine.geometry.verticesNeedUpdate = true;\n// \t\t\t}\n\n// \t\t}\n// \t}\n\n// \t/*renderer.domElement.ontouchmove = function(e) {\n// \t\tlet rect = e.target.getBoundingClientRect();\n// \t\tlet x = e.targetTouches[0].pageX - rect.left;\n// \t\tlet y = e.targetTouches[0].pageY - rect.top;\n// \t\trenderer.domElement.onmousemove({\n// \t\t\toffsetX: x,\n// \t\t\toffsetY: y\n// \t\t});\n// \t}*/\n\n// \t// renderer.domElement.ontouchstart = function(e) {\n// \t// \tlet rect = e.target.getBoundingClientRect();\n// \t// \tlet x = e.targetTouches[0].pageX - rect.left;\n// \t// \tlet y = e.targetTouches[0].pageY - rect.top;\n// \t// \trenderer.domElement.onclick({\n// \t// \t\toffsetX: x,\n// \t// \t\toffsetY: y\n// \t// \t});\n// \t// }\n\n// \tfunction makeDistanceSprite() {\n\n// \t\tlet canvas = document.createElement('canvas');\n// \t\tlet ctx = canvas.getContext('2d');\n// \t\tlet fontsize = 32;\n\n// \t\tctx.font = 'bolder ' + fontsize + 'px \"Open Sans\", Arial';\n// \t\tlet v = activeLine.geometry.vertices;\n// \t\tlet length = v[0].clone().sub(v[1]).length().toFixed(1);\n// \t\tlet text = '~ ' + length;\n// \t\tlet size = ctx.measureText(text);\n// \t\tlet paddingLeft = 20;\n// \t\tlet paddingTop = 10;\n// \t\tlet margin = 10;\n// \t\tcanvas.width = size.width + paddingLeft * 2 + margin * 2;\n// \t\tcanvas.height = fontsize + paddingTop * 2 + margin * 2;\n\n// \t\tctx.shadowBlur = 10;\n// \t\tctx.shadowColor = '#555';\n// \t\tctx.fillStyle = '#009bff';\n// \t\troundRect(ctx, margin, margin, canvas.width - margin * 2, canvas.height - margin * 2, 10);\n\n// \t\tctx.shadowBlur = 0;\n// \t\tctx.fillStyle = '#fff';\n// \t\tctx.textAlign = 'left';\n// \t\tctx.textBaseline = 'top';\n// \t\tctx.font = 'bolder ' + fontsize + 'px \"Open Sans\", Arial';\n// \t\tctx.fillText(text, paddingLeft + margin, paddingTop + margin);\n\n// \t\tlet texture = new THREE.CanvasTexture(canvas);\n// \t\tlet sprite = new THREE.Sprite(new THREE.SpriteMaterial({\n// \t\t\tmap: texture,\n// \t\t\tsizeAttenuation: false\n// \t\t}));\n\n// \t\tlet h = 0.7;\n// \t\tsprite.scale.set(0.002 * canvas.width, 0.0025 * canvas.height).multiplyScalar(h);\n\n// \t\tsprite.position.copy(v[0].clone().add(v[1]).multiplyScalar(0.5));\n// \t\tspriteScene.add(sprite);\n\n// \t}\n\n// \tfunction roundRect(ctx, x, y, w, h, r) { \n// \t\tctx.beginPath(); \n// \t\tctx.moveTo(x + r, y); \n// \t\tctx.lineTo(x + w - r, y); \n// \t\tctx.quadraticCurveTo(x + w, y, x + w, y + r); \n// \t\tctx.lineTo(x + w, y + h - r); \n// \t\tctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h); \n// \t\tctx.lineTo(x + r, y + h); \n// \t\tctx.quadraticCurveTo(x, y + h, x, y + h - r); \n// \t\tctx.lineTo(x, y + r); \n// \t\tctx.quadraticCurveTo(x, y, x + r, y); \n// \t\tctx.closePath(); \n// \t\tctx.fill();\n// \t} \n\t\n\t\n// \tfunction updateMeshInteractionMaterial(mesh) {\n// \t\tif (mesh.isHidden) {\n// \t\t\tmesh.interactionMaterial.color = hiddenColor;\n// \t\t\tmesh.interactionMaterial.opacity = hiddenAlpha;\n// \t\t} else {\n// \t\t\tmesh.interactionMaterial.opacity = 1;\n// \t\t}\n// \t\tif (mesh.isSelected) {\n// \t\t\tmesh.interactionMaterial.color = selectColor;\n// \t\t\tmesh.itemWrapper.querySelector('.graph-name').style.color = '#03a9f4';\n// \t\t} else {\n// \t\t\tmesh.itemWrapper.querySelector('.graph-name').style.color = 'inherit';\n// \t\t}\n// \t\tmesh.interactionMaterial.needsUpdate = true;\n// \t\tif (!mesh.isSelected && !mesh.isHidden) {\n// \t\t\tmesh.material = mesh.defaultMaterial;\n// \t\t} else {\n// \t\t\tmesh.material = mesh.interactionMaterial;\n// \t\t}\n// \t}\n\t\n// \tfunction onResize() {\n// \t\tlet width = wrapper.offsetWidth;\n// \t\tlet height = wrapper.offsetHeight;\n// \t\trenderer.setSize(width, height, false);\n// \t\tcamera.aspect = width / height;\n// \t\tcamera.updateProjectionMatrix();\n// \t}\n\t\n// \tonResize();\n\t\n// \twrapper.appendChild(renderer.domElement);\n// \twindow.addEventListener('resize', onResize, false);\n\t\n// \tlet gltfLoader = new THREE.GLTFLoader();\n// \tlet loadedScene = null;\n// \tlet loadedMeshes = [];\n\t\n// \tlet d = 5;\n\n// \tlet selectColor = new THREE.Color('#42006b');\n// \tlet hiddenColor = new THREE.Color('#555');\n// \tlet hiddenAlpha = 0.3;\n\n// \tlet interactionMaterial = new THREE.MeshPhongMaterial({\n// \t\ttransparent: true,\n// \t\tcolor: selectColor,\n// \t\tside: THREE.DoubleSide,\n// \t\tprecision: 'mediump'\n// \t});\n\t\n// \tfunction loadModel(url) {\n\t\t\n// \t\tresetAll();\n// \t\tif (loadedScene) {\n// \t\t\tscene.remove(loadedScene);\n// \t\t\tloadedScene = null;\n// \t\t\tloadedMeshes.length = 0;\n// \t\t}\n\t\t\n// \t\tshow(ViewerUI.loader);\n// \t\tViewerUI.modelBrowserContent.innerHTML = '';\n// \t\tViewerUI.loaderInfo.innerHTML = 'Loading model...';\n\t\t\n// \t\tgltfLoader.load(\n// \t\t\turl,\n// \t\t\tfunction onLoad(gltf) {\n\t\t\t\t\n// \t\t\t\tloadedScene = gltf.scene;\n// \t\t\t\tscene.add(gltf.scene);\n\n// \t\t\t\tgltf.scene = gltf.scene || gltf.scenes[0];\n\n// \t\t\t\tlet object = gltf.scene;\n\n// \t\t\t\tconst box = new THREE.Box3().setFromObject(object);\n// \t\t\t\tconst size = box.getSize(new THREE.Vector3()).length();\n// \t\t\t\tconst center = box.getCenter(new THREE.Vector3());\n\n// \t\t\t\tcontroller.reset();\n\n// \t\t\t\tobject.position.x += (object.position.x - center.x);\n// \t\t\t\tobject.position.y += (object.position.y - center.y);\n// \t\t\t\tobject.position.z += (object.position.z - center.z);\n// \t\t\t\tcontroller.maxDistance = size * 10;\n// \t\t\t\tcamera.near = size / 100;\n// \t\t\t\tcamera.far = size * 100;\n// \t\t\t\tcamera.updateProjectionMatrix();\n\n// \t\t\t\tcamera.position.copy(center);\n// \t\t\t\tcamera.position.x += size / 2.0;\n// \t\t\t\tcamera.position.y += size / 5.0;\n// \t\t\t\tcamera.position.z += size / 2.0;\n\n// \t\t\t\tdirectionalLight.position.setScalar(size);\n\n// \t\t\t\tcamera.lookAt(center);\n\n// \t\t\t\tcontroller.saveState();\n\n// \t\t\t\tgltf.scene.traverse((node) => {\n// \t\t\t\t\tif (node.isMesh && node.material) {\n// \t\t\t\t\t\tnode.geometry.computeBoundingBox();\n// \t\t\t\t\t\tnode.material.side = THREE.DoubleSide;\n// \t\t\t\t\t\tnode.material.precision = 'mediump';\n// \t\t\t\t\t\tnode.material.needsUpdate = true;\n// \t\t\t\t\t\tnode.interactionMaterial = interactionMaterial.clone();\n// \t\t\t\t\t\tnode.defaultMaterial = node.material;\n// \t\t\t\t\t\tnode.defaultPositionArray = Array.from(node.geometry.attributes.position.array);\n// \t\t\t\t\t\tnode.defaultPosition = node.position.clone();\n// \t\t\t\t\t\tloadedMeshes.push(node);\n// \t\t\t\t\t}\n// \t\t\t\t});\n\n// \t\t\t\tlet content = ViewerUI.modelBrowserContent;\n// \t\t\t\tlet counter = 0;\n// \t\t\t\tlet parentLevel = 0;\n\n// \t\t\t\tfunction makeSceneGraph(obj) {\n\t\t\t\t\t\n// \t\t\t\t\tif (obj.children.length === 0 && !obj.isMesh) {\n// \t\t\t\t\t\treturn;\n// \t\t\t\t\t}\n\t\t\t\t\t\n// \t\t\t\t\tlet itemWrapper = document.createElement('div');\n// \t\t\t\t\titemWrapper.classList.add('graph-item-wrapper');\n\t\t\t\t\t\n// \t\t\t\t\tlet item = document.createElement('div');\n// \t\t\t\t\titem.classList.add('graph-item');\n\t\t\t\t\t\n// \t\t\t\t\titemWrapper.appendChild(item);\n\t\t\t\t\t\n// \t\t\t\t\tcontent.appendChild(itemWrapper);\n// \t\t\t\t\tlet n = 0;\n// \t\t\t\t\tlet obj2 = obj;\n// \t\t\t\t\twhile (obj2 != gltf.scene) {\n// \t\t\t\t\t\tobj2 = obj2.parent;\n// \t\t\t\t\t\tn++;\n// \t\t\t\t\t}\n\t\t\t\t\t\n// \t\t\t\t\titem.style.paddingLeft = n * 1.5 + 'em';\n// \t\t\t\t\tobj.itemWrapper = itemWrapper;\n\t\t\t\t\t\n// \t\t\t\t\tlet left = document.createElement('div');\n// \t\t\t\t\tleft.classList.add('graph-left');\n// \t\t\t\t\tlet right = document.createElement('div');\n// \t\t\t\t\tright.classList.add('graph-right');\n// \t\t\t\t\titem.appendChild(left);\n// \t\t\t\t\titem.appendChild(right);\n\t\t\t\t\t\n// \t\t\t\t\tif (obj.children.length > 0) {\n\t\t\t\t\t\t\n// \t\t\t\t\t\tparentLevel++;\n// \t\t\t\t\t\tlet folder = document.createElement('div');\n\t\t\t\t\t\t\n// \t\t\t\t\t\tfolder.style.marginRight = '10px';\n// \t\t\t\t\t\tfolder.classList.add('graph-folder');\n// \t\t\t\t\t\tfolder.innerHTML = '<i class=\"fa fa-folder-open\"></i>';\n// \t\t\t\t\t\tleft.appendChild(folder);\n\t\t\t\t\t\t\n// \t\t\t\t\t\tobj.isFolderOpen = true;\n// \t\t\t\t\t\tobj.openFolder = function() {\n// \t\t\t\t\t\t\tfolder.innerHTML = obj.isFolderOpen ? '<i class=\"fa fa-folder-open\"></i>' :  '<i class=\"fa fa-folder\"></i>';\n// \t\t\t\t\t\t\tobj.traverse(child => {\n// \t\t\t\t\t\t\t\tif (obj === child) {\n// \t\t\t\t\t\t\t\t\treturn;\n// \t\t\t\t\t\t\t\t}\n// \t\t\t\t\t\t\t\tif (child.itemWrapper) {\n// \t\t\t\t\t\t\t\t\tif (child.parent.isFolderOpen && obj.isFolderOpen) {\n// \t\t\t\t\t\t\t\t\t\tchild.itemWrapper.style.display = 'block';\n// \t\t\t\t\t\t\t\t\t}\n// \t\t\t\t\t\t\t\t\tif (!obj.isFolderOpen) {\n// \t\t\t\t\t\t\t\t\t\tchild.itemWrapper.style.display = 'none';\n// \t\t\t\t\t\t\t\t\t}\n// \t\t\t\t\t\t\t\t}\n// \t\t\t\t\t\t\t});\n// \t\t\t\t\t\t}\n\t\t\t\t\t\t\n// \t\t\t\t\t\t// folder.onclick = () => {\n// \t\t\t\t\t\t// \tobj.isFolderOpen = !obj.isFolderOpen;\n// \t\t\t\t\t\t// \tobj.openFolder();\n// \t\t\t\t\t\t// }\n\t\t\t\t\t\t\n// \t\t\t\t\t\tfor (let i = 0; i < obj.children.length; i++) {\n// \t\t\t\t\t\t\tmakeSceneGraph(obj.children[i]);\n// \t\t\t\t\t\t}\n\t\t\t\t\t\t\n// \t\t\t\t\t}\n\t\t\t\t\t\n// \t\t\t\t\tlet name = document.createElement('div');\n// \t\t\t\t\tname.classList.add('graph-name');\n// \t\t\t\t\tname.innerHTML = obj.name || 'None';\n// \t\t\t\t\tleft.appendChild(name);\n\t\t\t\t\t\n// \t\t\t\t\t// name.onclick = function() {\n// \t\t\t\t\t// \tresetSelect();\n// \t\t\t\t\t// \tobj.traverse(child => {\t\n// \t\t\t\t\t// \t\tchild.isSelected = true;\n// \t\t\t\t\t// \t\tif (child.isMesh && child.material) {\n// \t\t\t\t\t// \t\t\tupdateMeshInteractionMaterial(child);\n// \t\t\t\t\t// \t\t}\n// \t\t\t\t\t// \t\tupdateSelectDom(child)\n// \t\t\t\t\t// \t});\n// \t\t\t\t\t// }\n\t\t\t\t\t\n// \t\t\t\t\tlet visible = document.createElement('div');\n// \t\t\t\t\tvisible.classList.add('graph-visible');\n// \t\t\t\t\tvisible.innerHTML = '<i class=\"fa fa-eye\"></i>';\n\t\t\t\t\t\n// \t\t\t\t\tobj.showMesh = function() {\n// \t\t\t\t\t\tvisible.innerHTML = obj.isMeshVisible ? '<i class=\"fa fa-eye\"></i>' : '<i class=\"fa fa-eye-slash\"></i>';\n// \t\t\t\t\t\tobj.traverse(child => {\n// \t\t\t\t\t\t\tif (child.itemWrapper) {\n// \t\t\t\t\t\t\t\tlet eye = child.itemWrapper.querySelector('.graph-visible');\n// \t\t\t\t\t\t\t\teye.innerHTML = obj.isMeshVisible ? '<i class=\"fa fa-eye\"></i>' : '<i class=\"fa fa-eye-slash\"></i>';\n// \t\t\t\t\t\t\t\teye.style.color = obj.isMeshVisible ? 'inherit' : 'rgba(0, 0, 0, 0.3)';\n// \t\t\t\t\t\t\t}\n// \t\t\t\t\t\t\tif (child.isMesh && child.material) {\n// \t\t\t\t\t\t\t\tchild.isHidden = !obj.isMeshVisible;\n// \t\t\t\t\t\t\t\tupdateMeshInteractionMaterial(child);\n// \t\t\t\t\t\t\t}\n// \t\t\t\t\t\t});\n// \t\t\t\t\t}\n\t\t\t\t\t\n// \t\t\t\t\tobj.isHidden = false;\n// \t\t\t\t\tobj.isSelected = false;\n// \t\t\t\t\tobj.isMeshVisible = true;\n// \t\t\t\t\t// visible.onclick = function() {\n// \t\t\t\t\t// \tobj.isMeshVisible = !obj.isMeshVisible;\n// \t\t\t\t\t// \tobj.showMesh();\n// \t\t\t\t\t// }\n\t\t\t\t\t\n// \t\t\t\t\tright.appendChild(visible)\n\t\t\t\t\t\n// \t\t\t\t}\n\t\t\t\t\n// \t\t\t\tmakeSceneGraph(gltf.scene)\n\n// \t\t\t\thide(ViewerUI.loader);\n\t\t\t\t\n// \t\t\t},\n// \t\t\tfunction onProgress(xhr) {\n// \t\t\t\tViewerUI.loaderInfo.innerHTML = Math.round(xhr.loaded / xhr.total * 100) + '% loaded';\n// \t\t\t},\n// \t\t\tfunction onError(err) {\n// \t\t\t\tViewerUI.loaderInfo.innerHTML = 'Error loading model! See console for more info.';\n// \t\t\t\tconsole.error('Error loading model!', err);\n// \t\t\t}\n// \t\t);\n\t\t\n// \t}\n\t\n// \tlet controller = new THREE.OrbitControls(camera, renderer.domElement);\n// \tcontroller.enabled = true;\n// \tcontroller.enableDamping = true;\n// \tcontroller.dampingFactor = 0.5;\n// \tcontroller.screenSpacePanning = true;\n\n// \tlet cubeController = new THREE.OrbitControls(camera, cubeRenderer.domElement);\n// \tcubeController.enablePan = false;\n// \tcubeController.enableZoom = false;\n// \tcubeController.rotateSpeed = 0.125;\n\t\n// \tlet selectedModeElement = ViewerUI.toggleOrbit;\n// \tsetOrbitMode();\n\n// \tcamera.position.z = d;\n// \tcamera.lookAt(scene.position);\n// \tcontroller.update();\n// \tcontroller.saveState();\n\t\n// \tlet ambientLight = new THREE.AmbientLight();\n// \tambientLight.intensity = 1;\n// \tscene.add(ambientLight);\n\n// \tlet directionalLight = new THREE.DirectionalLight();\n// \tdirectionalLight.position.set(200, 200, 200)\n// \tdirectionalLight.intensity = 0.5;\n// \tscene.add(directionalLight);\n\t\n// \t/*let light1 = new THREE.PointLight(0xffffff);\n// \tlight1.position.set(100, 100, 100);\n// \tscene.add(light1);\n\t\n// \tlet light2 = new THREE.PointLight(0xffffff);\n// \tlight2.position.set(100, 100, -100);\n// \tscene.add(light2);\n\t\n// \tlet light3 = new THREE.PointLight(0xffffff);\n// \tlight3.position.set(-100, 100, 100);\n// \tscene.add(light3);\n\t\n// \tlet light4 = new THREE.PointLight(0xffffff);\n// \tlight4.position.set(-100, 100, -100);\n// \tscene.add(light4);\n\t\n// \tlight1.intensity = light2.intensity = light3.intensity = light4.intensity = 0.3;*/\n\t\n// \tlet stop = false;\n\n// \tfunction renderAll() {\n\n// \t\trenderer.clear();\n// \t\trenderer.render(scene, camera);\n// \t\tupdateCubeCamera();\n// \t\tcubeRenderer.render(cubeScene, cubeCamera);\n\n// \t\trenderer.clearDepth();\n\n// \t\tif (isInMeasureMode) {\n// \t\t\trenderer.clearDepth();\n// \t\t\trenderer.render(lineScene, camera);\n// \t\t\trenderer.clearDepth();\n// \t\t\trenderer.render(spriteScene, camera);\n// \t\t}\n// \t}\n\t\n// \tfunction animate(time) {\n\n// \t\tif (stop) {\n// \t\t\treturn;\n// \t\t}\n\n// \t\tif (play) {\n// \t\t\tlet now = Date.now();\n// \t\t\tlet x = Math.min(1, (now - startTime) / duration);\n// \t\t\tcamera.position.copy(oldPosition).lerp(newPosition, x)\n// \t\t\tif (x === 1) {\n// \t\t\t\tplay = false;\n// \t\t\t}\n// \t\t}\n\t\t\n// \t\trequestAnimationFrame(animate);\n// \t\tcontroller.update();\n// \t\trenderAll();\n// \t}\n\t\n// \trequestAnimationFrame(animate);\n\t\n// \treturn {\n// \t\tloadModel: loadModel\n// \t};\n\t\n// }\n\n// function draggable(ele, toggleEle) {\n\t\n// \tlet startX = 0;\n// \tlet startY = 0;\n\t\n// \tfunction onMouseDown(evt) {\n// \t\tevt = evt || window.event;\n// \t\tstartDrag(evt.clientX, evt.clientY);\n// \t\twindow.addEventListener('mousemove', onMouseMove, true);\n// \t}\n\t\n// \tfunction onMouseMove(evt) {\n// \t\tevt = evt || window.event;\n// \t\tlet newX = evt.clientX;\n// \t\tlet newY = evt.clientY;\n// \t\tmoveDrag(newX, newY);\n// \t}\n\t\n// \tfunction onMouseUp() {\n// \t\twindow.removeEventListener('mousemove', onMouseMove, true);\n// \t}\n\t\n// \tfunction startDrag(x, y) {\n// \t\tstartX = x;\n// \t\tstartY = y;\n// \t}\n\t\n// \tfunction moveDrag(newX, newY) {\n\t\t\n// \t\tlet deltaX = newX - startX;\n// \t\tlet deltaY = newY - startY;\n\t\t\n// \t\tstartX = newX;\n// \t\tstartY = newY;\n\n// \t\tlet x = ele.offsetLeft + deltaX;\n// \t\tlet y = ele.offsetTop + deltaY;\n// \t\tx < 0 && (x = 0);\n// \t\ty < 0 && (y = 0);\n// \t\tlet w = ele.parentNode.offsetWidth - ele.offsetWidth;\n// \t\tlet h = ele.parentNode.offsetHeight - ele.offsetHeight;\n// \t\tx > w && (x = w);\n// \t\ty > h && (y = h);\n\n// \t\tele.style.left = x + 'px';\n// \t\tele.style.top = y + 'px';\n\t\t\n// \t}\n\t\n// \ttoggleEle.addEventListener('mousedown', onMouseDown, true);\n// \twindow.addEventListener('mouseup', onMouseUp, true);\n\t\n// }\n\n\n"],"mappings":"AAAA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}